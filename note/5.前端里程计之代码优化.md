# 从零开始做自动驾驶定位(五): 前端里程计之代码优化

## 整体框架

本次代码内容是相对上一次代码的优化，主要目的：高内聚，低耦合。主要做了如下更改：

- 新增：front_end/、models/、config/、srv/

- 修改：front_end_node.cpp

逐一解释一下。

## 逐一击破

### front_end/

该文件夹主要包含两个类：FrontEnd 和 FrontEndFlow。

- front_end：前端里程计的核心部分，包括更新位姿，点云配准，发布当前帧与地图等。在全局地图的发布中，并不是每次都发布全局地图，而是只发布一次全局地图（最后的时候），将每一关键祯存到了硬盘上，即生成 pcd 格式保存至硬盘，在最后发布全局地图时，将之前存的 pcd 文逐一读取出来，添加至同一点云内，之后再发布。

- front_end_flow：整个前端的流程，接收传感器数据，对数据进行处理（调用 front_end 的函数），最终发布内容，其作用类似于上一篇中 front_end_node.cpp 内的内容，文件内将前端里程计的流程封装成一个 Run() 函数。

以上两个类将前端里程计的流程分开了，front_end 处理一些核心的东西（更新位姿，点云配准，发布地图等），而 front_end_flow 封装了整个前端的流程，其内部包含一个 front_end 的指针，需要时调用 front_end 内的函数。

### models/

该文件夹主要包含两方面内容：Filter 和 Registration，主要目的是通过改写它们，达到多态的目的，进而便于后续使用不同的方法。

首先包含一个虚基类，这个虚基类仅包含必要的函数，具体的方法（Voxel、ndt）独自编写一个类并分别继承各自的虚基类，如果想增加其他的方法，便可像它们一样，编写一个类，继承虚基类并重写纯虚函数。

多态的实现在 front_end.cpp 文件中的 FrontEnd::InitRegistration 与 FrontEnd::InitFilter 函数内，对于存在的方法，添加该方法的分支即可。如果使用其他方法即可在配置文件中设置具体的方法，在此处实现多态。

这样的改写相较于之前的编写，在新增方法并使用新增的方法方面，给编写代码的人来说带来了极大的方便，对于修改的地方极少（只需添加 else if 分支），其余都是增加，并且不会破坏原有代码的结构。

### config/

里面包含了 config.yaml 的配置文件，主要是存放一些参数的，在函数内部通过 YAML::Node 匹配相关参数去找该文件内的参数设定值。

参数都放在了这里，对于查看与修改都很方便。

### srv/

包含了 saveMap.srv 文件，该文件定义的是消息服务时的参数，用于发布全局地图。

### front_end_node.cpp

该文件的内容被极大简化了，仅仅创建了一个 FrontEndFlow 类型的指针，然后调用 Run() 函数，便实现了整个的前端里程计。

main 函数非常简洁，这也是大多数优秀代码一致的风格。